<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Редактор картинок в WebGL</title>
<link rel="stylesheet" type="text/css" href="data/style.css">
<script src="data/data_fragment_shaders.js"></script>
<script type="text/javascript">
var vertex_shader = `attribute vec2 a_position;
uniform vec2 u_translation;
uniform vec2 u_scale;
varying vec2 v_texCoord;
void main() {
	gl_Position = vec4(a_position * u_scale + u_translation, 0, 1);
	v_texCoord = vec2((a_position.x + 1.0) / 2.0, (a_position.y - 1.0) / -2.0);
}`;

let createElement = (name, ...attr) => {
	let elm = document.createElement(name);
	for(let arr_set of attr)elm.setAttribute(arr_set[0], arr_set[1]);
	return elm;
};
//// Основные переменные.
let canvas;
let gl;
let canvas_width;
let canvas_height;
let img_width, img_height;
let gl_translation_x, gl_translation_y, gl_scale_x, gl_scale_y;
let scale_co = 1;
////

//// Основные переменные.
// data_fragment_shaders
let active_elm;
function activate_code(elm){
	active_elm.style.display = 'none';
	elm.style.display = 'block';
	active_elm = elm;
	
	// Сборка проги с новым фрагментным шейдером.
	
	// Рендеринг.
	render();
	
}

function resizeCanvasToDisplaySize(){
	canvas.width  = canvas.clientWidth;
	canvas.height = canvas.clientHeight;
}

function createShader(gl, type, source){
	let shader = gl.createShader(type);   // создание шейдера
	gl.shaderSource(shader, source);      // устанавливаем шейдеру его программный код
	gl.compileShader(shader);             // компилируем шейдер
	let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	if(success){                        // если компиляция прошла успешно - возвращаем шейдер
		return shader;
	}

	error(gl.getShaderInfoLog(shader));
	gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader){
	let program = gl.createProgram();
	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);
	gl.linkProgram(program);
	let success = gl.getProgramParameter(program, gl.LINK_STATUS);
	if(success){
		return program;
	}

	console.log(gl.getProgramInfoLog(program));
	gl.deleteProgram(program);
}

var program, positionLocation, scaleLocation, translationLocation, positionBuffer;
let active_img;
function render(){
	if(active_elm == undefined || active_img == undefined)return;
	resizeCanvasToDisplaySize();
	gl = canvas.getContext("webgl");
	if (!gl) {
		return;
	}

	// setup GLSL program
	let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertex_shader);
	let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, active_elm.textContent);
	program = createProgram(gl, vertexShader, fragmentShader);
	
	

	// look up where the vertex data needs to go.
	positionLocation = gl.getAttribLocation(program, "a_position");

	// lookup uniforms
	scaleLocation = gl.getUniformLocation(program, "u_scale");
	translationLocation = gl.getUniformLocation(program, "u_translation");

	// Create a buffer to put three 2d clip space points in
	positionBuffer = gl.createBuffer();

	// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
		-1.0,  -1.0,
		1.0,  -1.0,
		-1.0,  1.0,
		-1.0,  1.0,
		1.0,  -1.0,
		1.0,  1.0
	]), gl.STATIC_DRAW);



	// Create a texture.
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);

	// Set the parameters so we can render any size image.
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

	// Upload the image into the texture.
	try{
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, active_img);
	}catch(e){
		alert(e);
	}

	// Tell WebGL how to convert from clip space to pixels
	//gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	r();
}

function r(){

  // Clear the canvas
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Tell it to use our program (pair of shaders)
  gl.useProgram(program);

  // Turn on the position attribute
  gl.enableVertexAttribArray(positionLocation);

  // Bind the position buffer.
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
  var size = 2;          // 2 components per iteration
  var type = gl.FLOAT;   // the data is 32bit floats
  var normalize = false; // don't normalize the data
  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
  var offset = 0;        // start at the beginning of the buffer
  gl.vertexAttribPointer(
      positionLocation, size, type, normalize, stride, offset);


  // set the resolution
  gl.uniform2f(scaleLocation, gl_scale_x * scale_co, gl_scale_y * scale_co);
  gl.uniform2f(translationLocation, gl_translation_x, gl_translation_y);

  // Draw the rectangle.
  var primitiveType = gl.TRIANGLES;
  var offset = 0;
  var count = 6;
  gl.drawArrays(primitiveType, offset, count);
}

let mouse_down = (e, f) => {
	e.preventDefault();
	let onMouseUp = e => {
		document.removeEventListener('mouseup', onMouseUp);
		document.removeEventListener('mousemove', f);
	};
	document.addEventListener('mousemove', f);
	document.addEventListener('mouseup', onMouseUp);
};

window.onload = function(){
	canvas = document.getElementById("canvas");
	
	canvas.onmousedown = e => {
		mouse_down(e, e => {
			gl_translation_x += e.movementX / canvas.width * 2;
			gl_translation_y -= e.movementY / canvas.height * 2;
			r();
		});
	};
	
	let step_delta = 18;
	let delta = 100 ** (1 / step_delta);
	let delta_minus = 1 / delta;
	canvas.onwheel = e => {
		e.preventDefault();
		let temp_scale_co = scale_co;
		scale_co *= e.deltaY > 0 ? delta: delta_minus;
		if(scale_co < .01)scale_co = .01;
		if(scale_co > 100)scale_co = 100;
		let offset_x_temp = (e.offsetX / canvas.width * 2 - 1 - gl_translation_x) / (gl_scale_x * temp_scale_co);
		let offset_x = (e.offsetX / canvas.width * 2 - 1 - gl_translation_x) / (gl_scale_x * scale_co);
		let offset_y_temp = (1 - (e.offsetY / canvas.height * 2) - gl_translation_y) / (gl_scale_y * temp_scale_co);
		let offset_y = (1 - (e.offsetY / canvas.height * 2) - gl_translation_y) / (gl_scale_y * scale_co);
		gl_translation_x -= (offset_x_temp - offset_x) * (gl_scale_x * scale_co);
		gl_translation_y -= (offset_y_temp - offset_y) * (gl_scale_y * scale_co);
		r();
	};
	
	//// Загрузчик фоток
	let upload_photo_input = createElement("input", ["type", "file"], ["accept", "image/*"], ["multiple", ""]);
	upload_photo_input.onchange = () => {
		for(let i = 0; i < upload_photo_input.files.length; i++){
			// Проверка по фориату.
			if(!upload_photo_input.files[i].type.startsWith("image/"))continue;
			
			let img = createElement("img");
			img.file = upload_photo_input.files[i];
			
			img.onclick = () => {
				info(img.file.name + " " + img.file.type + " " + img.file.size);
				// Установка текстуры.
				active_img = img;
				img.src = reader.result;
				img_width = img.naturalWidth;
				img_height = img.naturalHeight;
				
				gl_scale_x = img_width / canvas.width;
				gl_scale_y = img_height / canvas.height;
				
				gl_translation_x = gl_scale_x * scale_co - 1;
				gl_translation_y = 1 - gl_scale_y * scale_co;
				// Рендеринг.
				render();
			};
			
			let span = createElement("span");
			span.appendChild(img);
			
			let span_delet = createElement("span", ["class", "button_delet"]);
			span_delet.onclick = () => span.remove();
			span.appendChild(span_delet);
			
			
			document.getElementById("uploaded_photos_img_view").appendChild(span);
			
			let reader = new FileReader();
			reader.onload = () => {
				img.src = reader.result;
				
			};
			reader.readAsDataURL(upload_photo_input.files[i]);
		}
	};
	document.getElementById("uploaded_photos_button").onclick = () => {
		upload_photo_input.click();
	};
	
	//// Меню фрагментных шейдеров. // данные в var data_fragment_shaders
	let shaders_content = document.getElementById("shaders_content");
	data_fragment_shaders.forEach((elm, i) => {
		let name_shader = createElement("div", ["class", "name_shader"]);
		name_shader.textContent = elm.name;
		let code_shader = createElement("pre", ["class", "code_shader"], ["contenteditable", "true"], ["spellcheck", "false"]);
		code_shader.textContent = elm.code;
		
		//*
		code_shader.onkeydown = (e) => {
			if(event.code !== 'Tab')return;
			
			e.preventDefault();
			let selection = window.getSelection();
			let node = code_shader.firstChild;
			info(code_shader.firstChild.nodeName);
			let offset = selection.anchorOffset;
			let focus = selection.focusOffset;
			if(offset > focus){
				offset ^= focus;
				focus ^= offset;
				offset ^= focus;
			}
			if(selection.anchorNode !== code_shader.firstChild){
				offset = 0;
				focus = code_shader.textContent.length;
			}
			node.replaceData(offset, focus - offset, "\t")
			selection.setPosition(node, offset + 1);
		};
		
		
		shaders_content.appendChild(name_shader);
		shaders_content.appendChild(code_shader);
		
		name_shader.onclick = () => activate_code(code_shader);
		if(i == 0){
			active_elm = code_shader;
			activate_code(code_shader);
		}
		name_shader.ondblclick = () => {// Перенести эту обработку в activate_code(elm).
			code_shader.textContent = data_fragment_shaders[i].code;
			// Сборка проги с новым фрагментным шейдером.
			
			// Рендеринг.
			
		};
		
	});
	
	
	//// Рендеринг сцены
	
};

function error(text){
	info("ERROR: " + text);
	//console.log("ERROR: " + text);
}
function info(text){
	document.getElementById("info").innerHTML=text;
}
</script>
</head>
<body>
	<canvas id="canvas"></canvas>
	<div id="uploaded_photos_menu">
		<div id="uploaded_photos_head">
			<span id="uploaded_photos_button">Загрузить</span>
		</div>
		<div id="uploaded_photos_img_view"></div>
	</div>
	<div id="shaders_menu">
		<div id="shaders_head">Фрагментные шейдеры</div>
		<div id="shaders_content"></div>
	</div>
	<pre id="info"></pre>
</body>
</html>