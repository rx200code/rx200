<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Пересечение отрезков.</title>
<script type="text/javascript">
/*
{ геометрические алгоритмы: Пересекаются ли 2 отрезка?                     }
{ ------------------------------------------------------------------------ }
{ Определяет пересечение отрезков A(ax1,ay1,ax2,ay2) и B (bx1,by1,bx2,by2),}
{ функция возвращает TRUE - если отрезки пересекаются, а если пересекаются }
{ в концах или вовсе не пересекаются, возвращается FALSE (ложь)            }
{ ------------------------------------------------------------------------ }
function Intersection(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2:real):boolean;
var v1,v2,v3,v4:real;
begin
   v1:=(bx2-bx1)*(ay1-by1)-(by2-by1)*(ax1-bx1);
   v2:=(bx2-bx1)*(ay2-by1)-(by2-by1)*(ax2-bx1);
   v3:=(ax2-ax1)*(by1-ay1)-(ay2-ay1)*(bx1-ax1);
   v4:=(ax2-ax1)*(by2-ay1)-(ay2-ay1)*(bx2-ax1);
   Intersection:=(v1*v2<0) and (v3*v4<0);
end;
//*/
/// Пояснение
// https://grafika.me/node/237
// https://acmp.ru/article.asp?id_text=170
function intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2){
	let v1=(bx2-bx1)*(ay1-by1)-(by2-by1)*(ax1-bx1);
	let v2=(bx2-bx1)*(ay2-by1)-(by2-by1)*(ax2-bx1);
	let v3=(ax2-ax1)*(by1-ay1)-(ay2-ay1)*(bx1-ax1);
	let v4=(ax2-ax1)*(by2-ay1)-(ay2-ay1)*(bx2-ax1);
	return (v1*v2<0) && (v3*v4<0);
};


// Функция, наклона координат, относительно центра на заданный угол.
let point_to_angle = (c, center, angle) => {
	let x = c[0] - center[0];
	let y = c[1] - center[1];
	let a = Math.atan2(y, x) - angle;
	let r = (x ** 2 + y ** 2) ** .5;
	c[0] = (center[0] + r * Math.cos(a));
	c[1] = (center[1] + r * Math.sin(a));
};
/*
function inPoly(x,y){
	npol = xp.length;
	let j = npol - 1;
	let c = 0;
	for(let i = 0; i < npol;i++){
		if ((((yp[i]<=y) && (y<yp[j])) || ((yp[j]<=y) && (y<yp[i]))) &&
		(x > (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i])) {
			c = !c
		}
		j = i;
	}
	return c;
}
//*/
function inPoly2(x, y, rect){
	let j = rect.length - 2;
	let c = 0;
	for(let i = 0; i < rect.length; i += 2){
		if ((((rect[i + 1] <= y) && (y < rect[j + 1])) || ((rect[j + 1] <= y) && (y < rect[i + 1]))) &&
		(x > (rect[j] - rect[i]) * (y - rect[i + 1]) / (rect[j + 1] - rect[i + 1]) + rect[i])) {
			c = !c
		}
		j = i;
	}
	return c;
}
function inPoly(rect_main, rect){
	for(let i = 0; i < 8; i += 2)if(inPoly2(rect_main[i], rect_main[i + 1], rect))return true;
	return false;
}
//function test_intersection(rect_main, rect){return true;};
//*
function test_intersection(rect_main, rect){
	// TEST 0
	if(inPoly(rect_main, rect))return true;
	if(inPoly(rect, rect_main))return true;
	// TEST 1
	for(let i = 0; i < 8; i += 2)for(let k = 0; k < 8; k += 2){
		if(intersection(rect_main[i], rect_main[i + 1], rect_main[(i + 2) % 8], rect_main[(i + 3) % 8], rect[k], rect[k + 1], rect[(k + 2) % 8], rect[(k + 3) % 8]))return true;
	}
	// END TEST 1
	return false;
};//*/
/*
function test_intersection(rect_main, rect){
	// TEST 0
	
	// TEST 1
	for(let i = 0; i < 8; i += 2)for(let k = 0; k < 8; k += 2){
		if(intersection(rect_main[i], rect_main[i + 1], rect_main[(i + 2) % 8], rect_main[(i + 3) % 8], rect[k], rect[k + 1], rect[(k + 2) % 8], rect[(k + 3) % 8]))return true;
	}
	// END TEST 1
	if(inPoly(rect_main, rect))return true;
	return inPoly(rect, rect_main);
};//*/
var view = new Object();
let flagMove = false;
let centerX = 500;
let centerY = 400;
let offsetX = 50;
let offsetY = 40;
view.start = function(){
    this.width = 1000;
    this.height = 800;
    this.color = "#e9e9e9";
    this.canvas = document.createElement('canvas');
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    document.body.prepend(this.canvas);
    this.c = this.canvas.getContext('2d'); 
    this.c.fillStyle = this.color;
    this.c.fillRect(0, 0, this.width, this.height);
	
	/// rect.
	let rect_count = 300;
	this.rects = [];
	function random(min, max){
		return Math.random() * (max - min) + min;
	}
	for(let i = 0; i < rect_count; i++){
		let c_x = random(0, this.width);// 0 this.width = 1000
		let c_y = random(0, this.height);// 0 this.height = 800;
		let w_2 = random(30, 300) / 2;// w 30 300
		let h_2 = random(24, 240) / 2;// h 24 240
		let r = (w_2 ** 2 + h_2 ** 2) ** .5;
		let angle = random(0, Math.PI * 2);// 0 Math.PI * 2; //let angle = 10 * (Math.PI / 180);
		let a = Math.atan2(-h_2, -w_2) + angle;
		let a_cos_r = Math.cos(a) * r;
		let a_sin_r = Math.sin(a) * r;
		let a2 = Math.atan2(-h_2, w_2) + angle;
		let a_cos_r2 = Math.cos(a2) * r;
		let a_sin_r2 = Math.sin(a2) * r;
		
		this.rects.push([
			c_x + a_cos_r, c_y + a_sin_r,
			c_x + a_cos_r2, c_y + a_sin_r2,
			c_x - a_cos_r, c_y - a_sin_r,
			c_x - a_cos_r2, c_y - a_sin_r2]);
	}
	
	let rect_main = [
		centerX - offsetX, centerY - offsetY,
		centerX + offsetX, centerY - offsetY,
		centerX + offsetX, centerY + offsetY,
		centerX - offsetX, centerY + offsetY];
	let setRect_main = function(){
		rect_main[0] = centerX - offsetX;
		rect_main[1] = centerY - offsetY;
		rect_main[2] = centerX + offsetX;
		rect_main[3] = centerY - offsetY;
		rect_main[4] = centerX + offsetX;
		rect_main[5] = centerY + offsetY;
		rect_main[6] = centerX - offsetX;
		rect_main[7] = centerY + offsetY;
	};
	this.view = function(){
		this.c.fillRect(0, 0, this.width, this.height);
		this.rects.forEach(rect => {
			//if(!test_intersection(rect_main, rect))return;
			this.c.beginPath();
			this.c.strokeStyle = test_intersection(rect_main, rect) ? "#f00" : "#000";
			this.c.moveTo(rect[0], rect[1]);
			this.c.lineTo(rect[2], rect[3]);
			this.c.lineTo(rect[4], rect[5]);
			this.c.lineTo(rect[6], rect[7]);
			this.c.closePath();
			this.c.stroke();
		});
		this.c.beginPath();
		this.c.strokeStyle = "#000";
		this.c.moveTo(rect_main[0], rect_main[1]);
		this.c.lineTo(rect_main[2], rect_main[3]);
		this.c.lineTo(rect_main[4], rect_main[5]);
		this.c.lineTo(rect_main[6], rect_main[7]);
		this.c.closePath();
		this.c.stroke();
		out("centerX "+centerX+"<br>centerY "+centerY)
	}.bind(this);
	this.view();
	this.down = function(e){
		flagMove = true;
		centerX = e.offsetX;
		centerY = e.offsetY;
		setRect_main();
		this.view();
	}.bind(this);
	this.canvas.addEventListener("mousedown", this.down);
	this.move = function(e){
		if(flagMove){
			centerX = e.offsetX;
			centerY = e.offsetY;
			setRect_main();
			this.view();
		}
	}.bind(this);
	this.canvas.addEventListener("mousemove", this.move);
	this.up = function(e){
		flagMove = false;
		centerX = e.offsetX;
		centerY = e.offsetY;
		setRect_main();
		this.view();
	}.bind(this);
	this.canvas.addEventListener("mouseup", this.up);
	
	/*
	this.click = function(e){
		this.bx1 = e.offsetX;
		this.by1 = e.offsetY;
		this.view();
	}.bind(this);
	this.canvas.addEventListener("click", this.click);
	//*/
}
window.onload = function(){
	view.start();
}
function out(text){
	document.getElementById("output").innerHTML=text;
}
</script>
</head>
<body>
<!--TEST-->
<br>
<span id="output"></span>
<!--TEST-->
</body>
</html>

